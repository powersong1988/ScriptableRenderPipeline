
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/VaryingMesh.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/VertMesh.hlsl"

struct SurfaceDescriptionInputs
        {
            float3 ObjectSpaceNormal;
            float3 ViewSpaceNormal;
            float3 WorldSpaceNormal;
            float3 TangentSpaceNormal;

            float3 ObjectSpaceTangent;
            float3 ViewSpaceTangent;
            float3 WorldSpaceTangent;
            float3 TangentSpaceTangent;

            float3 ObjectSpaceBiTangent;
            float3 ViewSpaceBiTangent;
            float3 WorldSpaceBiTangent;
            float3 TangentSpaceBiTangent;

            float3 ObjectSpaceViewDirection;
            float3 ViewSpaceViewDirection;
            float3 WorldSpaceViewDirection;
            float3 TangentSpaceViewDirection;

            float3 ObjectSpacePosition;
            float3 ViewSpacePosition;
            float3 WorldSpacePosition;
            float3 TangentSpacePosition;

            float4 ScreenPosition;
            float4 uv0;
            float4 uv1;
            float4 uv2;
            float4 uv3;
            float4 VertexColor;
            float FaceSign;
};

${VFXSGSurfaceStruct}
${VFXSGSurfaceFunction}

    void Frag( VFX_VARYING_PS_INPUTS packedInput,OUTPUT_GBUFFER(outGBuffer))
    {
        // Unused
        float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0

        SurfaceDescriptionInputs surfaceDescriptionInputs;
        
        SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                
        SurfaceData surfaceData;
        BuiltinData builtinData;
        float3 bentNormalWS;
        BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);

        // Builtin Data
        // For back lighting we use the oposite vertex normal 
        InitBuiltinData(surfaceDescription.Alpha, bentNormalWS, -fragInputs.worldToTangent[2], fragInputs.positionRWS, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);
        
        // override sampleBakedGI:

        builtinData.emissiveColor = surfaceDescription.Emission;

        // TODO: Handle depth offset
        //builtinData.depthOffset = 0.0;

#if (SHADERPASS == SHADERPASS_DISTORTION)
        builtinData.distortion = surfaceDescription.Distortion;
        builtinData.distortionBlur = surfaceDescription.DistortionBlur;
#else
        builtinData.distortion = float2(0.0, 0.0);
        builtinData.distortionBlur = 0.0;
#endif

        PostInitBuiltinData(V, posInput, surfaceData, builtinData);

        ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);
    }