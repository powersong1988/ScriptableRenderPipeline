
    
${VFXSGSurfaceStruct}
${VFXSGSurfaceFunction}

    void Frag( PackedVaryingsToPS packedInput,OUTPUT_GBUFFER(outGBuffer))
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);
        FragInputs input = UnpackVaryingsMeshToFragInputs(packedInput.vmesh);

        // input.positionSS is SV_Position
        PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

    #ifdef VARYINGS_NEED_POSITION_WS
        float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);
    #else
        // Unused
        float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0
    #endif

        SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                
        SurfaceData surfaceData;
        BuiltinData builtinData;
        float3 bentNormalWS;
        BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);

        // Builtin Data
        // For back lighting we use the oposite vertex normal 
        InitBuiltinData(surfaceDescription.Alpha, bentNormalWS, -fragInputs.worldToTangent[2], fragInputs.positionRWS, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);
        
        // override sampleBakedGI:

        builtinData.emissiveColor = surfaceDescription.Emission;

        // TODO: Handle depth offset
        //builtinData.depthOffset = 0.0;

#if (SHADERPASS == SHADERPASS_DISTORTION)
        builtinData.distortion = surfaceDescription.Distortion;
        builtinData.distortionBlur = surfaceDescription.DistortionBlur;
#else
        builtinData.distortion = float2(0.0, 0.0);
        builtinData.distortionBlur = 0.0;
#endif

        PostInitBuiltinData(V, posInput, surfaceData, builtinData);

        ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);
    }